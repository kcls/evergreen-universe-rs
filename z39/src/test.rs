use crate::message::*;

#[test]
fn test_initialize_request() {
    // Example InitializeRequest from YAZ client.
    let bytes = [
        0xb4, 0x52, 0x83, 0x02, 0x00, 0xe0, 0x84, 0x03, 0x00, 0xe9, 0xa2, 0x85, 0x04, 0x04, 0x00,
        0x00, 0x00, 0x86, 0x04, 0x04, 0x00, 0x00, 0x00, 0x9f, 0x6e, 0x02, 0x38, 0x31, 0x9f, 0x6f,
        0x03, 0x59, 0x41, 0x5a, 0x9f, 0x70, 0x2f, 0x35, 0x2e, 0x33, 0x31, 0x2e, 0x31, 0x20, 0x63,
        0x33, 0x63, 0x65, 0x61, 0x38, 0x38, 0x31, 0x65, 0x33, 0x65, 0x37, 0x65, 0x38, 0x30, 0x62,
        0x30, 0x36, 0x39, 0x64, 0x64, 0x64, 0x31, 0x34, 0x32, 0x39, 0x39, 0x39, 0x34, 0x65, 0x35,
        0x38, 0x38, 0x34, 0x31, 0x61, 0x63, 0x62, 0x31, 0x34,
    ];

    let msg = Message::from_bytes(&bytes).unwrap().unwrap();

    let MessagePayload::InitializeRequest(payload) = msg.payload() else {
        panic!("Wrong message type parsed: {msg:?}");
    };

    assert_eq!(Some("YAZ"), payload.implementation_name().as_deref());

    assert_eq!(bytes, *msg.to_bytes().unwrap());

    // Verify valid, partial messages return None instead of Err
    assert!(Message::from_bytes(&bytes[0..10]).unwrap().is_none());
}

#[test]
fn test_initialize_response() {
    // Note the 26h byte (a boolean value) in Yaz in 0x01, but it's
    // 0xff in rasn.  Changed here to allow the tests to pass.

    // Bytes taking from a Yaz client init request
    let bytes = [
        0xb5, 0x7f, 0x83, 0x02, 0x00, 0xe0, 0x84, 0x03, 0x00, 0xe9, 0x82, 0x85, 0x04, 0x04, 0x00,
        0x00, 0x00, 0x86, 0x04, 0x04, 0x00, 0x00, 0x00, 0x8c, 0x01, 0xff, 0x9f, 0x6e, 0x05, 0x38,
        0x31, 0x2f, 0x38, 0x31, 0x9f, 0x6f, 0x25, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x32, 0x5a,
        0x4f, 0x4f, 0x4d, 0x20, 0x55, 0x6e, 0x69, 0x76, 0x65, 0x72, 0x73, 0x61, 0x6c, 0x20, 0x47,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2f, 0x47, 0x46, 0x53, 0x2f, 0x59, 0x41, 0x5a, 0x9f,
        0x70, 0x34, 0x31, 0x2e, 0x30, 0x34, 0x2f, 0x35, 0x2e, 0x33, 0x31, 0x2e, 0x31, 0x20, 0x63,
        0x33, 0x63, 0x65, 0x61, 0x38, 0x38, 0x31, 0x65, 0x33, 0x65, 0x37, 0x65, 0x38, 0x30, 0x62,
        0x30, 0x36, 0x39, 0x64, 0x64, 0x64, 0x31, 0x34, 0x32, 0x39, 0x39, 0x39, 0x34, 0x65, 0x35,
        0x38, 0x38, 0x34, 0x31, 0x61, 0x63, 0x62, 0x31, 0x34,
    ];

    let msg = Message::from_bytes(&bytes).unwrap().unwrap();

    let MessagePayload::InitializeResponse(payload) = msg.payload() else {
        panic!("Wrong message type parsed: {msg:?}");
    };

    assert_eq!(
        Some("Simple2ZOOM Universal Gateway/GFS/YAZ"),
        payload.implementation_name().as_deref()
    );

    assert_eq!(bytes, *msg.to_bytes().unwrap());
}

#[test]
fn test_payloaduest() {
    // Byte 14 replaces 0x01 with 0xff for rasn-consistent boolean value
    let bytes = [
        0xb6, 0x4e, 0x8d, 0x01, 0x00, 0x8e, 0x01, 0x01, 0x8f, 0x01, 0x00, 0x90, 0x01, 0xff, 0x91,
        0x01, 0x31, 0xb2, 0x07, 0x9f, 0x69, 0x04, 0x6b, 0x63, 0x6c, 0x73, 0xb5, 0x34, 0xa1, 0x32,
        0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x13, 0x03, 0x01, 0xa0, 0x27, 0xbf, 0x66, 0x24, 0xbf,
        0x2c, 0x14, 0x30, 0x08, 0x9f, 0x78, 0x01, 0x01, 0x9f, 0x79, 0x01, 0x07, 0x30, 0x08, 0x9f,
        0x78, 0x01, 0x05, 0x9f, 0x79, 0x01, 0x01, 0x9f, 0x2d, 0x0a, 0x30, 0x38, 0x37, 0x39, 0x33,
        0x30, 0x33, 0x37, 0x32, 0x37,
    ];

    let msg = Message::from_bytes(&bytes).unwrap().unwrap();

    let MessagePayload::SearchRequest(payload) = msg.payload() else {
        panic!("Wrong message type parsed: {msg:?}");
    };

    // Example extracting the ISBN from this query via pattern syntax.
    // Included here for my own reference.
    /*
    let Query::Type1(
        RpnQuery {
            rpn: RpnStructure::Op(Operand::AttrTerm(
                AttributesPlusTerm {
                    term: Term::General(ref isbn),
                    ..
                }
            )),
            ..
        }
    ) = payload.query else {
        panic!();
    };
    */

    // Extract the ISBN from within the query one piece at a time.
    let Query::Type1(ref rpn_query) = payload.query() else {
        panic!();
    };
    let RpnStructure::Op(ref operand) = rpn_query.rpn() else {
        panic!();
    };
    let Operand::AttrTerm(ref term) = operand else {
        panic!();
    };
    let Term::General(ref isbn) = term.term() else {
        panic!();
    };

    assert_eq!(&OID_ATTR_SET_BIB1, rpn_query.attribute_set());

    /*
    let s = rpn_query.attribute_set().to_string();
    println!("{s}");
    println!("{payload:?}");
    */

    // Compare the bytes
    assert_eq!(*b"0879303727", **isbn);
    // OR the String
    assert_eq!("0879303727", std::str::from_utf8(&isbn.slice(..)).unwrap());

    assert_eq!(bytes, *msg.to_bytes().unwrap());
}

#[test]
fn test_search_response() {
    // Final bool changed from 0x01 to 0xff
    let bytes = [
        0xb7, 0x0c, 0x97, 0x01, 0x01, 0x98, 0x01, 0x00, 0x99, 0x01, 0x01, 0x96, 0x01, 0xff,
    ];

    let msg = Message::from_bytes(&bytes).unwrap().unwrap();

    let MessagePayload::SearchResponse(payload) = msg.payload() else {
        panic!("Wrong message type parsed: {msg:?}");
    };

    assert_eq!(payload.result_count(), &1);

    assert_eq!(bytes, *msg.to_bytes().unwrap());
}

#[test]
fn test_present_request() {
    let bytes = [
        0xb8, 0x14, 0x9f, 0x1f, 0x01, 0x31, 0x9e, 0x01, 0x01, 0x9d, 0x01, 0x01, 0x9f, 0x68, 0x07,
        0x2a, 0x86, 0x48, 0xce, 0x13, 0x05, 0x0a,
    ];

    let msg = Message::from_bytes(&bytes).unwrap().unwrap();

    let MessagePayload::PresentRequest(payload) = msg.payload() else {
        panic!("Wrong message type parsed: {msg:?}");
    };

    println!("\n{payload:?}");

    assert_eq!(
        &OID_MARC21,
        payload.preferred_record_syntax().as_ref().unwrap()
    );

    assert_eq!(bytes, *msg.to_bytes().unwrap());
}
